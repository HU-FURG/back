generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}


datasource db {
  provider  = "postgresql"
  url  	    = env("DATABASE_URL")
}

enum Hierarquia {
  admin
  user
}

enum typeSchedule {
  consulta
  aula
}

enum PcEventType {
  iniciou
  usou
  encerrou
}

enum availabilityStatus {
  ok        //  poderia ser qualquer outra sala
  bom       //  sala boa mas poderia ser outra parecida
  excelente  //  Pouca probabilidade de ter salas similares disponiveis
}

model SystemLog { //controle do sistema
  id           Int      @id @default(autoincrement())
  key          String   @unique
  value        String?
  autoApprove  Boolean   @default(false)
  updatedAt    DateTime @updatedAt
  createdAt    DateTime @default(now())
}

model User {
  id           Int       @id @default(autoincrement())
  login        String    @unique
  senha        String

  email        String?   @unique
  nome         String?   
  descricao    String?
  telefone     String?

  hierarquia      Hierarquia @default(user)
  especialidadeId Int?
  lastLogin_at    DateTime?

  createdAt       DateTime  @default(now())
  active          Boolean   @default(true)

  // Relações 
  especialidade   EspecialidadeUser? @relation(fields: [especialidadeId], references: [id])

  periodsCreated   RoomPeriod[] @relation("PeriodCreatedBy")
  periodsFor       RoomPeriod[] @relation("PeriodScheduledFor")
  
  scheduleTemplates     RoomScheduleTemplate[]
  notificationsReceived Notification[]
}

model EspecialidadeRoom {
  id    Int    @id @default(autoincrement())
  nome  String @unique

  especialidadesAceitas EspecialidadeUser[] @relation("RoomAceitas")

  rooms Room[]
}

model EspecialidadeUser {
  id    Int    @id @default(autoincrement())
  nome  String @unique

  users User[]

  roomsAceitas EspecialidadeRoom[] @relation("RoomAceitas")
}


model BlocoRoom {
  id    Int    @id @default(autoincrement())
  nome  String @unique

  rooms Room[]

  maps Map[]
}


model Room {
  id              Int      @id @default(autoincrement())
  ID_Ambiente     String   @unique

  blocoId         Int
  especialidadeId Int

  tipo            String
  banheiro        Boolean
  ambiente        String
  area            Float
  active          Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  bloco           BlocoRoom @relation(fields: [blocoId], references: [id])
  especialidade   EspecialidadeRoom @relation(fields: [especialidadeId], references: [id])

  periods RoomPeriod[]

  mapRooms MapRoom[]
}

model PcUsageEvent {
  id Int @id @default(autoincrement())

  // =========================
  // ORIGEM
  // =========================
  roomIdAmbiente String      // "x"
  eventType      PcEventType // iniciou | usou | encerrou
  targetApp      String?     // chrome.exe

  // =========================
  // TEMPO
  // =========================
  eventTime DateTime

  createdAt  DateTime @default(now())

  @@index([roomIdAmbiente, eventTime])
}


model RoomPeriod {
  id          Int      @id @default(autoincrement())
  roomId      Int

  // controle de quem crio e para quem foi agendado
  createdById Int
  scheduledForId Int?

  // dia de inicio dia de fim do agendamento, para controle de recorrência e métricas
  startSchedule DateTime
  endSchedule   DateTime
  countRecurrence Int? 
  atualRecurrenceCount Int? @default(0) // para controle de recorrência

  // controle do dia
  start       DateTime //foco na hora
  end         DateTime //foco na hora
  weekday     Int?     //dia da semana 

  // avaliçao da reserva
  availabilityStatus availabilityStatus? @default(ok)
  // pra que proposito
  typeSchedule typeSchedule? @default(consulta)

  isRecurring Boolean  @default(false)
  approved    Boolean  @default(false) // saber se foi realmente aprovado

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  room Room  @relation(fields: [roomId], references: [id])
  createdBy   User @relation("PeriodCreatedBy", fields: [createdById], references: [id])
  scheduledFor   User? @relation("PeriodScheduledFor", fields: [scheduledForId], references: [id])

  @@index([roomId, start])
  @@index([roomId, end])
  @@index([createdById])
  @@index([scheduledForId])
}

// --- Novo Sistema de Templates/Reagendamento ---
// Este modelo armazena agendamentos que podem ser re-agendados. Um agendamento é movido para cá quando vence ou é cancelado.
model RoomScheduleTemplate {
  id                Int      @id @default(autoincrement())
  userId            Int?
  nome              String
  durationInMinutes Int

  // Detalhes da Sala (para caso a sala seja excluída)
  roomIdAmbiente    String
  roomBloco         String

  // Detalhes da Ação
  originalStart     DateTime // Início original (para referência)
  originalEnd       DateTime // Fim original (para referência)
  
  reason            String  // Motivo da template (e.g., "Vencido", "Cancelado")
  archivedAt        DateTime @default(now())

  user User? @relation(fields: [userId], references: [id])
}

// --- Histórico para Análises Individuais ---
model PeriodHistory {
  id Int @id @default(autoincrement())

  // =========================
  // SNAPSHOT DA SALA
  // =========================
  roomIdAmbiente String
  roomBloco      String
  roomTipo       String?

  // =========================
  // IDS (SEM FK)
  // =========================
  createdById     Int?
  scheduledForId  Int?

  // =========================
  // SNAPSHOT USUÁRIO
  // =========================
  createdByLogin     String?
  createdByNome      String?
  scheduledForLogin  String?
  scheduledForNome   String?

  // =========================
  // PERÍODO
  // =========================
  start    DateTime
  end      DateTime
  weekday  Int?

  used         Boolean  @default(false)
  startService DateTime?
  endService   DateTime?

  // =========================
  // MÉTRICAS
  // =========================
  durationMinutes       Int?
  actualDurationMinutes Int?

  archivedAt DateTime @default(now())

  @@index([roomIdAmbiente])
  @@index([createdById])
  @@index([scheduledForId])
  @@index([roomIdAmbiente, start])
}


// Esta tabela deve ser preenchida por um Cron Job no final do dia (ex: 23:59)
model PeriodReportDaily {
  id             Int      @id @default(autoincrement())
  
  idPeriod       Int     // para referência cruzada entre reservadas do mesmo periodo agendado

  // controle de quem crio e para quem foi agendado
  createdById Int
  scheduledForId Int
  // horario q foi agendado
  start       DateTime //foco na hora
  end         DateTime //foco na hora
  // tempo usado pela pessoa que agendou (diferença entre startService e endService)
  totalUsedMinutes   Int?   

   // avaliçao da reserva
  availabilityStatus availabilityStatus? @default(ok)
  // pra que proposito
  typeSchedule typeSchedule?

  // pegar referencia em pcusedreference ligar ambos para fim de saber se usou
  used  Boolean? @default(true)
  // relacionar com historico de sala no dia
  roomDailyId Int

  roomDaily   roomTimeUsedDaily @relation("roomDailyforId", fields: [roomDailyId], references: [id])
  @@unique([idPeriod, roomDailyId])
}

// tempo usado na sala
model roomTimeUsedDaily {
  id             Int      @id @default(autoincrement())
  
  // Data de referência do relatório (ex: 2023-10-25T00:00:00.000Z)
  date           DateTime 
  generatedAt    DateTime @default(now())
  weekday       Int      // dia da semana (0-6)

  // Identificação da sala (Snapshot - string para manter histórico mesmo se Room for deletada)
  roomIdAmbiente String
  roomBloco      String

  totalUsedMinutes   Int   

  @@index([date])
  @@index([roomIdAmbiente, date])
  periodReportDailies PeriodReportDaily[] @relation("roomDailyforId")
}

// guarda informações gerais de uso diario das salas pelo mês
model RoomStats {
  id               Int       @id @default(autoincrement())
  //  Identificação da sala
  roomIdAmbiente   String
  roomBloco        String

  //  Período de referência (mês consolidado)
  monthRef         DateTime  // Ex: 2025-10-01 (representa o mês)

  //  Dados agregados gerais
  totalReservedMin Int       // soma do tempo reservado no mês
  totalUsedMin     Int       // soma do tempo realmente usado
  avgIdleMin       Float?    // média de tempo ocioso entre reservas
  avgUsageRate     Float?    // média (totalUsed / totalReserved)

  //  Distribuição por dia da semana (0-5)
  usageByWeekday   Json?     // exemplo: { "0": 300, "1": 700, ..., "6": 120 }

  //  Contagem de eventos
  totalBookings    Int       // total de agendamentos no mês
  totalUsed        Int       // quantos foram usados (used = true)
  totalCanceled    Int       // quantos não foram usados (used = false)

  // Timestamps
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  @@index([roomIdAmbiente, monthRef])
}

// --- Novo Sistema de Notificação ---
// Para avisar o cliente sobre o status de um agendamento.
model Notification {
  id            Int       @id @default(autoincrement())
  userId        Int       // Para quem é a notificação
  message       String    @db.Text
  isRead        Boolean   @default(false)
  type          String    // Tipo (e.g., "FIM_AGENDAMENTO", "CANCELAMENTO", "REAGENDAMENTO_SUCESSO")
  relatedRoomId Int?      // Opcional: ID da sala relacionada
  createdAt     DateTime  @default(now())

  user User @relation(fields: [userId], references: [id])
}


// Mapas

model Map {
  id        Int    @id @default(autoincrement())
  blocoId   Int    
  nome      String
  svgPath   String

  // posição do mapa no frontend (para caso queira mostrar mais de um mapa)
  posX Float
  posY Float
  andar Int

  salas     MapRoom[]
  
  bloco    BlocoRoom @relation(fields: [blocoId], references: [id])
}

model MapRoom {
  id         Int @id @default(autoincrement())
  mapId      Int
  roomId     Int @unique
  svgElementId String

  map  Map  @relation(fields: [mapId], references: [id])
  room Room @relation(fields: [roomId], references: [id])

  @@unique([mapId, svgElementId])
}
