generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider  = "postgresql"
  url  	    = env("DATABASE_URL")
}

enum Hierarquia {
  admin
  user
}

model SystemLog { //controle do sistema
  id           Int      @id @default(autoincrement())
  key          String   @unique
  value        String?
  autoApprove  Boolean   @default(false)
  updatedAt    DateTime @updatedAt
  createdAt    DateTime @default(now())
}

model User {
  id           Int       @id @default(autoincrement())
  login        String    @unique
  senha        String

  email        String?   @unique
  nome         String?   
  descricao    String?
  telefone     String?

  hierarquia      Hierarquia @default(user)
  especialidadeId Int?
  lastLogin_at    DateTime?

  createdAt       DateTime  @default(now())
  active          Boolean   @default(true)

  // Relações 
  especialidade   EspecialidadeUser? @relation(fields: [especialidadeId], references: [id])
  roomPeriods           RoomPeriod[]
  scheduleTemplates     RoomScheduleTemplate[]
  notificationsReceived Notification[]
  histories             PeriodHistory[]
}

model EspecialidadeUser {
  id    Int    @id @default(autoincrement())
  nome  String @unique

  // relações
  users User[]
}

model EspecialidadeRoom {
  id    Int    @id @default(autoincrement())
  nome  String @unique
  especialidadesAceitas String?

  // relações
  rooms Room[]
}

model Room {
  id            Int      @id @default(autoincrement())
  ID_Ambiente   String   @unique
  bloco         String
  especialidadeId Int
  

  tipo          String
  banheiro      Boolean
  ambiente      String
  area          Float
  active        Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  periods RoomPeriod[]
  especialidade   EspecialidadeRoom @relation(fields: [especialidadeId], references: [id])
}

model RoomPeriod {
  id          Int      @id @default(autoincrement())
  roomId      Int
  userId      Int?      // usuário que agendou
  nome        String    // pra quem foi agendado

  start       DateTime
  end         DateTime

  maxScheduleTime DateTime?

  isRecurring Boolean  @default(false)
  approved    Boolean  @default(false) // saber se foi realmente aprovado

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  room Room  @relation(fields: [roomId], references: [id])
  user User? @relation(fields: [userId], references: [id])

  @@index([roomId, start])
  @@index([roomId, end])
  @@index([userId])
}

// --- Novo Sistema de Templates/Reagendamento ---
// Este modelo armazena agendamentos que podem ser re-agendados. Um agendamento é movido para cá quando vence ou é cancelado.
model RoomScheduleTemplate {
  id                Int      @id @default(autoincrement())
  userId            Int?
  nome              String
  durationInMinutes Int

  // Detalhes da Sala (para caso a sala seja excluída)
  roomIdAmbiente    String
  roomBloco         String

  // Detalhes da Ação
  originalStart     DateTime // Início original (para referência)
  originalEnd       DateTime // Fim original (para referência)
  
  reason            String  // Motivo da template (e.g., "Vencido", "Cancelado")
  archivedAt        DateTime @default(now())

  user User? @relation(fields: [userId], references: [id])
}

// --- Histórico para Análises Individuais ---
model PeriodHistory {
  id             Int      @id @default(autoincrement())

  // Detalhe da sala 
  roomIdAmbiente String   
  roomBloco      String

  // Detalhe de quem agendou
  userId         Int?   
  user           User?    @relation(fields: [userId], references: [id])  

  // Detalhes do Período
  start          DateTime
  end            DateTime
  weekday        Int?     

  // Pra quem foi agendado
  nome           String
  used           Boolean @default(false)   
  startService   DateTime?
  endService     DateTime?  

  // Para analise
  durationMinutes       Int?
  actualDurationMinutes Int?  
  archivedAt     DateTime @default(now())

  @@index([roomIdAmbiente])
  @@index([weekday])
  @@index([roomIdAmbiente, start])
  @@index([roomIdAmbiente, weekday, used])
}

// Esta tabela deve ser preenchida por um Cron Job no final do dia (ex: 23:59)
model DailyRoomReport {
  id             Int      @id @default(autoincrement())
  
  // Data de referência do relatório (ex: 2023-10-25T00:00:00.000Z)
  date           DateTime 
  generatedAt    DateTime @default(now())

  // Identificação da sala (Snapshot - string para manter histórico mesmo se Room for deletada)
  roomIdAmbiente String
  roomBloco      String

  // Verifica se a sala estava ativa no sistema neste dia
  wasActive      Boolean
  totalUsedMinutes   Int?   

  // Minutos ociosos (Tempo total disponível no dia - Tempo usado)
  // *O cálculo do tempo total disponível depende da sua regra de negócio (ex: 8h as 18h = 600min)*
  totalUnusedMinutes Int?   

  // Quantidade de agendamentos que foram cancelados ou não realizados neste dia
  cancellationCount  Int?

  // Lista JSON com nomes e IDs das pessoas que efetivamente usaram a sala no dia
  // Formato sugerido: [{"nome": "Carlos", "userId": 1}, {"nome": "Maria", "userId": null}]
  attendedUsersList  Json?

  @@index([date])
  @@index([roomIdAmbiente, date])
}


// guarda informações gerais de uso diario das salas pelo mês
model RoomStats {
  id               Int       @id @default(autoincrement())
  //  Identificação da sala
  roomIdAmbiente   String
  roomBloco        String

  //  Período de referência (mês consolidado)
  monthRef         DateTime  // Ex: 2025-10-01 (representa o mês)

  //  Dados agregados gerais
  totalReservedMin Int       // soma do tempo reservado no mês
  totalUsedMin     Int       // soma do tempo realmente usado
  avgIdleMin       Float?    // média de tempo ocioso entre reservas
  avgUsageRate     Float?    // média (totalUsed / totalReserved)

  //  Distribuição por dia da semana (0-5)
  usageByWeekday   Json?     // exemplo: { "0": 300, "1": 700, ..., "6": 120 }

  //  Contagem de eventos
  totalBookings    Int       // total de agendamentos no mês
  totalUsed        Int       // quantos foram usados (used = true)
  totalCanceled    Int       // quantos não foram usados (used = false)

  // Timestamps
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  @@index([roomIdAmbiente, monthRef])
}

// --- Novo Sistema de Notificação ---
// Para avisar o cliente sobre o status de um agendamento.
model Notification {
  id            Int       @id @default(autoincrement())
  userId        Int       // Para quem é a notificação
  message       String    @db.Text
  isRead        Boolean   @default(false)
  type          String    // Tipo (e.g., "FIM_AGENDAMENTO", "CANCELAMENTO", "REAGENDAMENTO_SUCESSO")
  relatedRoomId Int?      // Opcional: ID da sala relacionada
  createdAt     DateTime  @default(now())

  user User @relation(fields: [userId], references: [id])
}
